<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Guide to React Hooks and State Management 2025 | RemoteToolHub</title>
    <meta name="description" content="Master React Hooks and modern state management patterns in 2025. Learn useState, useEffect, custom hooks, Zustand, and advanced patterns.">
    <meta name="keywords" content="React, hooks, state management, useState, useEffect, custom hooks, Zustand, Redux, 2025">
    <meta name="author" content="RemoteToolHub">
    <meta property="og:title" content="Complete Guide to React Hooks and State Management 2025">
    <meta property="og:description" content="Comprehensive guide to React Hooks and state management patterns for modern applications">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://remotetoolhub.com/blog/articles/react-hooks-state-management-2025.html">
    <meta property="og:image" content="https://remotetoolhub.com/blog/assets/images/react-hooks-2025.jpg">
    <link rel="canonical" href="https://remotetoolhub.com/blog/articles/react-hooks-state-management-2025.html">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            margin-top: 20px;
            margin-bottom: 20px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: linear-gradient(135deg, #61dafb 0%, #21759b 100%);
            color: white;
            border-radius: 15px;
            margin: -20px -20px 40px -20px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header .meta {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .hook-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
            border-left: 5px solid #61dafb;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .hook-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.1);
        }
        
        .hook-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .hook-icon {
            width: 60px;
            height: 60px;
            margin-right: 20px;
            border-radius: 10px;
            background: #61dafb;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.2em;
        }
        
        .hook-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .hook-subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            position: relative;
        }
        
        .code-example::before {
            content: attr(data-lang);
            position: absolute;
            top: 5px;
            right: 10px;
            background: #4a5568;
            color: #e2e8f0;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }
        
        .pattern-showcase {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }
        
        .pattern-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border-color: #61dafb;
        }
        
        .pattern-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .pattern-icon {
            width: 40px;
            height: 40px;
            background: #61dafb;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 1.2em;
            color: white;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .comparison-table th {
            background: #61dafb;
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .comparison-table tr:hover {
            background: #f8f9fa;
        }
        
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .pros, .cons {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .pros h4 {
            color: #27ae60;
            margin-bottom: 10px;
        }
        
        .cons h4 {
            color: #e74c3c;
            margin-bottom: 10px;
        }
        
        .best-practices {
            background: #e8f5e8;
            border-radius: 8px;
            padding: 25px;
            margin: 25px 0;
        }
        
        .best-practices h4 {
            color: #27ae60;
            margin-bottom: 15px;
        }
        
        .best-practices ul {
            list-style: none;
        }
        
        .best-practices li {
            margin: 8px 0;
            position: relative;
            padding-left: 25px;
        }
        
        .best-practices li::before {
            content: '‚úì';
            position: absolute;
            left: 0;
            color: #27ae60;
            font-weight: bold;
        }
        
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .warning-box h4 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .interactive-demo {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border: 2px dashed #61dafb;
        }
        
        .demo-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .demo-button {
            background: #61dafb;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .demo-button:hover {
            background: #21759b;
        }
        
        .demo-output {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            min-height: 50px;
        }
        
        .conclusion {
            background: linear-gradient(135deg, #61dafb 0%, #21759b 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin: 40px 0;
            text-align: center;
        }
        
        .cta-button {
            display: inline-block;
            background: #27ae60;
            color: white;
            padding: 12px 30px;
            text-decoration: none;
            border-radius: 25px;
            margin: 20px 10px;
            transition: background 0.3s ease;
        }
        
        .cta-button:hover {
            background: #219a52;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .pros-cons {
                grid-template-columns: 1fr;
            }
            
            .pattern-showcase {
                grid-template-columns: 1fr;
            }
            
            .hook-header {
                flex-direction: column;
                text-align: center;
            }
            
            .hook-icon {
                margin-right: 0;
                margin-bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Complete Guide to React Hooks and State Management 2025</h1>
            <div class="meta">
                <span>üìÖ Published: January 2025</span> | 
                <span>‚è±Ô∏è Read Time: 18 minutes</span> | 
                <span>üë®‚Äçüíª By RemoteToolHub Team</span>
            </div>
        </header>

        <article>
            <section>
                <h2>üöÄ Introduction</h2>
                <p>React Hooks revolutionized how we write React components, and in 2025, they've become even more powerful with new patterns and optimizations. This comprehensive guide covers everything from basic hooks to advanced state management patterns, helping you build scalable and maintainable React applications.</p>
            </section>

            <section>
                <h2>üìä React Hooks Overview</h2>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Hook</th>
                            <th>Purpose</th>
                            <th>Complexity</th>
                            <th>Performance Impact</th>
                            <th>Common Use Cases</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>useState</strong></td>
                            <td>Local state management</td>
                            <td>Easy</td>
                            <td>Low</td>
                            <td>Form inputs, toggles</td>
                        </tr>
                        <tr>
                            <td><strong>useEffect</strong></td>
                            <td>Side effects</td>
                            <td>Medium</td>
                            <td>Medium</td>
                            <td>API calls, subscriptions</td>
                        </tr>
                        <tr>
                            <td><strong>useContext</strong></td>
                            <td>Context consumption</td>
                            <td>Easy</td>
                            <td>Medium</td>
                            <td>Theme, auth state</td>
                        </tr>
                        <tr>
                            <td><strong>useReducer</strong></td>
                            <td>Complex state logic</td>
                            <td>Hard</td>
                            <td>Low</td>
                            <td>Form validation, state machines</td>
                        </tr>
                        <tr>
                            <td><strong>useMemo</strong></td>
                            <td>Expensive calculations</td>
                            <td>Medium</td>
                            <td>High</td>
                            <td>Data transformations</td>
                        </tr>
                        <tr>
                            <td><strong>useCallback</strong></td>
                            <td>Function memoization</td>
                            <td>Medium</td>
                            <td>High</td>
                            <td>Event handlers</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <div class="hook-card">
                <div class="hook-header">
                    <div class="hook-icon">üéØ</div>
                    <div>
                        <h3 class="hook-title">1. useState - State Management</h3>
                        <p class="hook-subtitle">The Foundation of React State</p>
                    </div>
                </div>
                <p>useState is the most fundamental hook for managing local component state. In 2025, we have new patterns and optimizations for better performance.</p>
                
                <div class="code-example" data-lang="React">
                    <h4>Basic useState Examples:</h4>
                    <pre><code>import React, { useState } from 'react';

// Basic counter example
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(prev => prev - 1)}>Decrement</button>
    </div>
  );
}

// Complex state with object
function UserProfile() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    preferences: {
      theme: 'light',
      notifications: true
    }
  });
  
  const updateUserName = (name) => {
    setUser(prev => ({
      ...prev,
      name
    }));
  };
  
  const updatePreferences = (key, value) => {
    setUser(prev => ({
      ...prev,
      preferences: {
        ...prev.preferences,
        [key]: value
      }
    }));
  };
  
  return (
    <div>
      <input 
        value={user.name}
        onChange={(e) => updateUserName(e.target.value)}
        placeholder="Name"
      />
      <label>
        <input
          type="checkbox"
          checked={user.preferences.notifications}
          onChange={(e) => updatePreferences('notifications', e.target.checked)}
        />
        Enable Notifications
      </label>
    </div>
  );
}

// Lazy initial state for expensive computations
function ExpensiveComponent() {
  const [data, setData] = useState(() => {
    // This function only runs once on initial render
    return computeExpensiveValue();
  });
  
  return <div>{data}</div>;
}</code></pre>
                </div>
                
                <div class="best-practices">
                    <h4>useState Best Practices:</h4>
                    <ul>
                        <li>Use functional updates when new state depends on previous state</li>
                        <li>Split state into multiple useState calls for unrelated data</li>
                        <li>Use lazy initial state for expensive computations</li>
                        <li>Avoid deeply nested state objects</li>
                        <li>Consider useReducer for complex state logic</li>
                    </ul>
                </div>
            </div>

            <div class="hook-card">
                <div class="hook-header">
                    <div class="hook-icon">‚ö°</div>
                    <div>
                        <h3 class="hook-title">2. useEffect - Side Effects</h3>
                        <p class="hook-subtitle">Managing Component Lifecycle</p>
                    </div>
                </div>
                <p>useEffect handles side effects in functional components. Understanding its dependency array and cleanup functions is crucial for preventing bugs and memory leaks.</p>
                
                <div class="code-example" data-lang="React">
                    <h4>useEffect Patterns:</h4>
                    <pre><code>import React, { useState, useEffect } from 'react';

// Basic data fetching
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let isCancelled = false;
    
    const fetchUsers = async () => {
      try {
        setLoading(true);
        const response = await fetch('/api/users');
        const userData = await response.json();
        
        if (!isCancelled) {
          setUsers(userData);
          setError(null);
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err.message);
        }
      } finally {
        if (!isCancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchUsers();
    
    // Cleanup function
    return () => {
      isCancelled = true;
    };
  }, []); // Empty dependency array - runs once
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Event listeners and cleanup
function WindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return <div>{windowSize.width} x {windowSize.height}</div>;
}

// Multiple effects for separation of concerns
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  
  // Effect for user data
  useEffect(() => {
    if (!userId) return;
    
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  // Effect for posts data
  useEffect(() => {
    if (!userId) return;
    
    fetchUserPosts(userId).then(setPosts);
  }, [userId]);
  
  // Effect for document title
  useEffect(() => {
    if (user) {
      document.title = `${user.name} - Profile`;
    }
    
    return () => {
      document.title = 'My App';
    };
  }, [user]);
  
  return (
    <div>
      {user && <h1>{user.name}</h1>}
      {posts.map(post => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}</code></pre>
                </div>
                
                <div class="warning-box">
                    <h4>‚ö†Ô∏è Common useEffect Pitfalls:</h4>
                    <ul>
                        <li><strong>Missing dependencies:</strong> Always include all values from component scope used inside useEffect</li>
                        <li><strong>Infinite loops:</strong> Be careful with object/array dependencies</li>
                        <li><strong>Memory leaks:</strong> Always cleanup subscriptions and cancel async operations</li>
                        <li><strong>Stale closures:</strong> Use functional updates or useCallback for event handlers</li>
                    </ul>
                </div>
            </div>

            <div class="hook-card">
                <div class="hook-header">
                    <div class="hook-icon">üîÑ</div>
                    <div>
                        <h3 class="hook-title">3. useReducer - Complex State Logic</h3>
                        <p class="hook-subtitle">Redux-like State Management</p>
                    </div>
                </div>
                <p>useReducer is perfect for managing complex state logic with multiple sub-values or when the next state depends on the previous one.</p>
                
                <div class="code-example" data-lang="React">
                    <h4>useReducer Examples:</h4>
                    <pre><code>import React, { useReducer } from 'react';

// Shopping cart reducer
const cartReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      const existingItem = state.items.find(item => item.id === action.payload.id);
      
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          ),
          total: state.total + action.payload.price
        };
      }
      
      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }],
        total: state.total + action.payload.price
      };
      
    case 'REMOVE_ITEM':
      const itemToRemove = state.items.find(item => item.id === action.payload);
      
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload),
        total: state.total - (itemToRemove.price * itemToRemove.quantity)
      };
      
    case 'UPDATE_QUANTITY':
      const { id, quantity } = action.payload;
      const item = state.items.find(item => item.id === id);
      const quantityDiff = quantity - item.quantity;
      
      return {
        ...state,
        items: state.items.map(item =>
          item.id === id ? { ...item, quantity } : item
        ),
        total: state.total + (item.price * quantityDiff)
      };
      
    case 'CLEAR_CART':
      return {
        items: [],
        total: 0
      };
      
    default:
      return state;
  }
};

function ShoppingCart() {
  const [cart, dispatch] = useReducer(cartReducer, {
    items: [],
    total: 0
  });
  
  const addItem = (product) => {
    dispatch({ type: 'ADD_ITEM', payload: product });
  };
  
  const removeItem = (id) => {
    dispatch({ type: 'REMOVE_ITEM', payload: id });
  };
  
  const updateQuantity = (id, quantity) => {
    dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });
  };
  
  const clearCart = () => {
    dispatch({ type: 'CLEAR_CART' });
  };
  
  return (
    <div>
      <h2>Shopping Cart (${cart.total.toFixed(2)})</h2>
      {cart.items.map(item => (
        <div key={item.id}>
          <span>{item.name} - ${item.price}</span>
          <input
            type="number"
            value={item.quantity}
            onChange={(e) => updateQuantity(item.id, parseInt(e.target.value))}
          />
          <button onClick={() => removeItem(item.id)}>Remove</button>
        </div>
      ))}
      <button onClick={clearCart}>Clear Cart</button>
    </div>
  );
}

// Form validation with useReducer
const formReducer = (state, action) => {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        values: {
          ...state.values,
          [action.field]: action.value
        },
        errors: {
          ...state.errors,
          [action.field]: ''
        }
      };
      
    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.error
        }
      };
      
    case 'SET_SUBMITTING':
      return {
        ...state,
        isSubmitting: action.isSubmitting
      };
      
    case 'RESET_FORM':
      return action.initialState;
      
    default:
      return state;
  }
};

function ContactForm() {
  const initialState = {
    values: { name: '', email: '', message: '' },
    errors: {},
    isSubmitting: false
  };
  
  const [form, dispatch] = useReducer(formReducer, initialState);
  
  const setField = (field, value) => {
    dispatch({ type: 'SET_FIELD', field, value });
  };
  
  const validateField = (field, value) => {
    let error = '';
    
    if (!value.trim()) {
      error = `${field} is required`;
    } else if (field === 'email' && !/\S+@\S+\.\S+/.test(value)) {
      error = 'Email is invalid';
    }
    
    dispatch({ type: 'SET_ERROR', field, error });
    return !error;
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Validate all fields
    const isValid = Object.keys(form.values).every(field =>
      validateField(field, form.values[field])
    );
    
    if (!isValid) return;
    
    dispatch({ type: 'SET_SUBMITTING', isSubmitting: true });
    
    try {
      await submitForm(form.values);
      dispatch({ type: 'RESET_FORM', initialState });
    } catch (error) {
      console.error('Form submission failed:', error);
    } finally {
      dispatch({ type: 'SET_SUBMITTING', isSubmitting: false });
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={form.values.name}
        onChange={(e) => setField('name', e.target.value)}
        onBlur={(e) => validateField('name', e.target.value)}
        placeholder="Name"
      />
      {form.errors.name && <span className="error">{form.errors.name}</span>}
      
      <input
        type="email"
        value={form.values.email}
        onChange={(e) => setField('email', e.target.value)}
        onBlur={(e) => validateField('email', e.target.value)}
        placeholder="Email"
      />
      {form.errors.email && <span className="error">{form.errors.email}</span>}
      
      <textarea
        value={form.values.message}
        onChange={(e) => setField('message', e.target.value)}
        onBlur={(e) => validateField('message', e.target.value)}
        placeholder="Message"
      />
      {form.errors.message && <span className="error">{form.errors.message}</span>}
      
      <button type="submit" disabled={form.isSubmitting}>
        {form.isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}</code></pre>
                </div>
            </div>

            <section>
                <h2>üéØ Modern State Management Solutions</h2>
                
                <div class="pattern-showcase">
                    <div class="pattern-card">
                        <div class="pattern-header">
                            <div class="pattern-icon">üêª</div>
                            <div>
                                <h3>Zustand</h3>
                                <p>Lightweight state management</p>
                            </div>
                        </div>
                        <p>Zustand provides a simple, unopinionated state management solution that's perfect for most React applications.</p>
                        
                        <div class="code-example" data-lang="JavaScript">
                            <pre><code>import { create } from 'zustand'

// Create a store
const useStore = create((set, get) => ({
  count: 0,
  user: null,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  setUser: (user) => set({ user }),
  reset: () => set({ count: 0, user: null })
}))

// Use in component
function Counter() {
  const { count, increment, decrement } = useStore()
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  )
}</code></pre>
                        </div>
                        
                        <div class="pros-cons">
                            <div class="pros">
                                <h4>‚úÖ Pros</h4>
                                <ul>
                                    <li>Minimal boilerplate</li>
                                    <li>TypeScript support</li>
                                    <li>No providers needed</li>
                                    <li>Great performance</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h4>‚ùå Cons</h4>
                                <ul>
                                    <li>Less ecosystem</li>
                                    <li>No time-travel debugging</li>
                                    <li>Newer library</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <div class="pattern-card">
                        <div class="pattern-header">
                            <div class="pattern-icon">üîÑ</div>
                            <div>
                                <h3>Redux Toolkit</h3>
                                <p>Modern Redux approach</p>
                            </div>
                        </div>
                        <p>Redux Toolkit simplifies Redux usage with less boilerplate and better defaults.</p>
                        
                        <div class="code-example" data-lang="JavaScript">
                            <pre><code>import { createSlice, configureStore } from '@reduxjs/toolkit'

// Create a slice
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1 // Immer makes this safe
    },
    decrement: (state) => {
      state.value -= 1
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload
    }
  }
})

// Configure store
const store = configureStore({
  reducer: {
    counter: counterSlice.reducer
  }
})

// Export actions
export const { increment, decrement, incrementByAmount } = counterSlice.actions</code></pre>
                        </div>
                        
                        <div class="pros-cons">
                            <div class="pros">
                                <h4>‚úÖ Pros</h4>
                                <ul>
                                    <li>Mature ecosystem</li>
                                    <li>Excellent DevTools</li>
                                    <li>Predictable state updates</li>
                                    <li>Great for large apps</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h4>‚ùå Cons</h4>
                                <ul>
                                    <li>More complex setup</li>
                                    <li>Steeper learning curve</li>
                                    <li>More boilerplate</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <div class="pattern-card">
                        <div class="pattern-header">
                            <div class="pattern-icon">‚öõÔ∏è</div>
                            <div>
                                <h3>Jotai</h3>
                                <p>Atomic state management</p>
                            </div>
                        </div>
                        <p>Jotai takes an atomic approach to state management, allowing you to compose state from small, independent atoms.</p>
                        
                        <div class="code-example" data-lang="JavaScript">
                            <pre><code>import { atom, useAtom } from 'jotai'

// Create atoms
const countAtom = atom(0)
const userAtom = atom(null)

// Derived atom
const doubleCountAtom = atom((get) => get(countAtom) * 2)

// Async atom
const userDataAtom = atom(async (get) => {
  const user = get(userAtom)
  if (!user) return null
  
  const response = await fetch(`/api/users/${user.id}`)
  return response.json()
})

// Use in component
function Counter() {
  const [count, setCount] = useAtom(countAtom)
  const [doubleCount] = useAtom(doubleCountAtom)
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {doubleCount}</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  )
}</code></pre>
                        </div>
                        
                        <div class="pros-cons">
                            <div class="pros">
                                <h4>‚úÖ Pros</h4>
                                <ul>
                                    <li>Fine-grained reactivity</li>
                                    <li>Excellent performance</li>
                                    <li>Composable atoms</li>
                                    <li>Great TypeScript support</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h4>‚ùå Cons</h4>
                                <ul>
                                    <li>Different mental model</li>
                                    <li>Smaller community</li>
                                    <li>Learning curve</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section>
                <h2>üõ†Ô∏è Custom Hooks Patterns</h2>
                
                <div class="hook-card">
                    <h3>Essential Custom Hooks</h3>
                    
                    <div class="code-example" data-lang="React">
                        <h4>Useful Custom Hooks:</h4>
                        <pre><code>// useLocalStorage hook
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  const setValue = useCallback((value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  return [storedValue, setValue];
}

// useDebounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// useAsync hook
function useAsync(asyncFunction, dependencies = []) {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null
  });

  useEffect(() => {
    let isCancelled = false;

    setState({ data: null, loading: true, error: null });

    asyncFunction()
      .then(data => {
        if (!isCancelled) {
          setState({ data, loading: false, error: null });
        }
      })
      .catch(error => {
        if (!isCancelled) {
          setState({ data: null, loading: false, error });
        }
      });

    return () => {
      isCancelled = true;
    };
  }, dependencies);

  return state;
}

// useToggle hook
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => setValue(v => !v), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);
  
  return [value, { toggle, setTrue, setFalse }];
}

// usePrevious hook
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  });
  
  return ref.current;
}

// Usage examples
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);
  const [savedSearches, setSavedSearches] = useLocalStorage('searches', []);
  
  const { data: results, loading, error } = useAsync(
    () => searchAPI(debouncedSearchTerm),
    [debouncedSearchTerm]
  );
  
  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      
      {loading && <div>Searching...</div>}
      {error && <div>Error: {error.message}</div>}
      {results && (
        <ul>
          {results.map(result => (
            <li key={result.id}>{result.title}</li>
          ))}
        </ul>
      )}
    </div>
  );
}</code></pre>
                    </div>
                </div>
            </section>

            <div class="interactive-demo">
                <h3>üéÆ Interactive Hook Demo</h3>
                <p>Try out different hooks and see how they work:</p>
                
                <div class="demo-controls">
                    <button class="demo-button" onclick="demoUseState()">useState Demo</button>
                    <button class="demo-button" onclick="demoUseEffect()">useEffect Demo</button>
                    <button class="demo-button" onclick="demoCustomHook()">Custom Hook Demo</button>
                </div>
                
                <div class="demo-output" id="demo-output">
                    Click a button above to see hook demonstrations!
                </div>
            </div>

            <div class="best-practices">
                <h4>üéØ React Hooks Best Practices 2025:</h4>
                <ul>
                    <li>Always use hooks at the top level of your React function</li>
                    <li>Use ESLint plugin for hooks to catch common mistakes</li>
                    <li>Prefer multiple useState calls over single complex state object</li>
                    <li>Use useCallback and useMemo judiciously - profile first</li>
                    <li>Create custom hooks for reusable stateful logic</li>
                    <li>Use useReducer for complex state logic with multiple sub-values</li>
                    <li>Always cleanup effects to prevent memory leaks</li>
                    <li>Use TypeScript for better hook type safety</li>
                    <li>Consider state management libraries for global state</li>
                    <li>Test your custom hooks with React Testing Library</li>
                </ul>
            </div>

            <div class="conclusion">
                <h2>üèÜ Conclusion</h2>
                <p>React Hooks have transformed how we build React applications, making them more functional and easier to reason about. In 2025, the ecosystem has matured with excellent state management solutions and patterns that scale from small projects to enterprise applications.</p>
                
                <p><strong>Key Takeaways:</strong> Master the fundamentals (useState, useEffect), learn when to use useReducer, explore modern state management solutions, and create reusable custom hooks for your common patterns.</p>
                
                <a href="#" class="cta-button">Start Building with Hooks</a>
                <a href="/blog" class="cta-button">Read More React Guides</a>
            </div>
        </article>
    </div>

    <script>
        // Interactive demo functions
        function demoUseState() {
            const output = document.getElementById('demo-output');
            output.innerHTML = `
                <h4>useState Demo</h4>
                <p><strong>Purpose:</strong> Manage local component state</p>
                <p><strong>Example:</strong> const [count, setCount] = useState(0)</p>
                <p><strong>Use Case:</strong> Form inputs, toggles, counters</p>
                <div style="background: #e8f5e8; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    <strong>‚úì Best Practice:</strong> Use functional updates when new state depends on previous state
                </div>
            `;
        }
        
        function demoUseEffect() {
            const output = document.getElementById('demo-output');
            output.innerHTML = `
                <h4>useEffect Demo</h4>
                <p><strong>Purpose:</strong> Handle side effects and lifecycle events</p>
                <p><strong>Example:</strong> useEffect(() => { /* side effect */ }, [dependencies])</p>
                <p><strong>Use Cases:</strong> API calls, subscriptions, DOM manipulation</p>
                <div style="background: #fff3cd; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    <strong>‚ö†Ô∏è Remember:</strong> Always cleanup subscriptions and cancel async operations
                </div>
            `;
        }
        
        function demoCustomHook() {
            const output = document.getElementById('demo-output');
            output.innerHTML = `
                <h4>Custom Hook Demo</h4>
                <p><strong>Purpose:</strong> Extract and reuse stateful logic</p>
                <p><strong>Example:</strong> const [value, toggle] = useToggle(false)</p>
                <p><strong>Benefits:</strong> Code reuse, separation of concerns, easier testing</p>
                <div style="background: #d4edda; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    <strong>üí° Tip:</strong> Start with 'use' prefix and follow hooks rules
                </div>
            `;
        }
        
        // Add smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Reading progress indicator
        const progressBar = document.createElement('div');
        progressBar.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, #61dafb, #21759b);
            z-index: 1000;
            transition: width 0.3s ease;
        `;
        document.body.appendChild(progressBar);

        window.addEventListener('scroll', () => {
            const scrolled = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
            progressBar.style.width = scrolled + '%';
        });
    </script>
</body>
</html>